# 引言
2020年9月中旬，我有一个朋友让我写一写关于模块化的知识。我第一时间想到的就是：

``` JavaScript
import React from 'react';

const _ = require('loash');
```

对于以上两行代码，我产生了以下几个问题
1. 为什么有的用import，有的用require
2. 如果分属与不同的规范，好像有听说过不能同时使用的传闻
3. 为什么需要模块化？

### 1. `import` 与 `require`

##### ESM

2016年5月，ECMAScript 6.0成为了国际标准，在这一标准中，首次使用了`import`和`export`关键字用于模块化方案，被称之为ES Module（简称 ESM）模块化解决方案，可以说是官方发（~~糖~~）话了。可是由于历史遗留原因，各种模块化解决方案已经占据了一定的市场，出现了并存的现象，以`require` 为代表的类`commonJs`解决方案就是其中一员。

##### CJS
为什么我说我们使用的`require`是类 `CommonJS`解决方案呢？因为真正的`CommonJS`是用于`nodeJs`模块化解决方案，该解决方案在浏览器端主要有以下两个弊端：
- 导出的变量如果没有function包裹，会暴露在全局变量中
- 服务端模块化可以使用同步加载依赖的方式，因为依赖保存在本地，读取本地文件的时间很短，但是浏览器端需要在网络中请求，时间较长阻塞浏览器加载，需要支持异步回调。

##### AMD

这两个重要缺陷，导致浏览器端不能直接使用`CommonJS`的规范解决模块化问题。这时候在当时的社区，出现了很多其他衍生的规范，其中，Async Module Definition（简称 AMD）便是其中最为成功的一种。AMD规范在继承了部分`CommonJS`的规范以外，还包含了以下内容

1. 定义全局函数`define(id, dependencies, factory)`，用于定义模块。
2. `id`为模块唯一标示，`dependencies`为模块的前置依赖，`factory`是对象或者函数
3. `factory`如果是函数，模块可以通过以下三种方式对外暴漏 API：`return` 任意类型；`exports.XModule = XModule`、`module.exports = XModule`。
4. `factory`如果是对象，则该对象即为模块的导出值。

2009年，遵循AMD规范的`RequireJS`发布后，迅速得到广大开发者的青睐。但是AMD规范的依赖是提前加载，而不管依赖是在函数中什么时候使用，造成了一定的性能消耗，而`CommonJS`规范是延迟加载、就近声明（就近依赖）的特性，不少开发者觉得应该使用这种加载依赖的方式。

##### CMD

2011年，国内阿里巴巴集团前端开发工程师玉伯（王保平），在给`RequireJS`提出修改意见不断被拒绝后，自己写了`SeaJS`，并提出了Common Module Definition（简称 CMD）规范，内容上与AMD规范相差无几，但是采取了延迟加载、就近声明的特性。`SeaJS`在国内得到了广泛的应用，但是在国外并没有得到大范围的推广。

这时如果同一套代码如果要同时运行在服务端和浏览器端，便会使用不同的模块化方案。

##### UMD
2014年，美籍华裔 Homa Wong 提出了Universal Module Definition（简称 UMD）解决方案，UMD提出了以下内容

1. 优先判断是否存在 `exports` 方法，如果存在，则采用 `CommonJS` 方式加载模块；
2. 其次判断是否存在 `define` 方法，如果存在，则采用 `AMD` 方式加载模块；
3. 最后判断 `global` 对象上是否定义了所需依赖，如果存在，则直接使用；反之，则抛出异常。

UMD解决方案使得经过webpack打包之后的代码具有跨平台运行的特性，成为更加通用的前端模块化解决方案。

### 2. 如何处理使用不同前端模块化方案的依赖

由于历史遗留原因，当我们使用npm导出的模块时，会发现模块可能时采用类`CommonJS`方案进行导出的。但自从ESM出现之后，很多开发者已经开始使用ESM的规范来导入模块。

如果要我们在使用模块之前，一个个查看模块使用不同的导入模块的方法，必定是非常麻烦的。这时候，常用于浏览器版本兼容的编译工具babel出场三下五除二解决了这个问题。

babel对使用ESM规范的导入导出统一编译成AMD规范的导入导出，这样我们在项目中混用`import` 与 `require`，不用对应依赖模块的导出方法，也不会出现问题了。

babel会对ESM规范导出的模块，会给导出对象一个`__esModule`的标示，用以标示使用ESM规范到处的模块。导入时，会判断是否存在`__esModule`属性，以对ESM规范和AMD规范导出的模块分别做不同的处理。

### 3. 为什么需要前端模块化

JavaScript早期作为一门轻量级脚本语言，并没有依赖管理的概念，当时只用于Web上与用户的少量交互使用。随着Web的发展，JavaScript书写的代码越来越复杂，全局变量冲突，自身没有依赖管理的问题大大困扰着开发者们。

在官方提供ESM规范之前，开发者们推出了自己的模块化规范解决方案，这些规范提供了ESM实现思路，推动了JavaScript语言的发展，也造成了多种模块化并存的情况。对于现在的开发者来说，由于babel这类的编译工具的存在，可以不用关心模块化的兼容问题。

# 结束语

[最后放出一个来自掘金的差异总结](https://juejin.im/post/6844903663404580878)

- AMD 与 CMD：
    - AMD是 RequireJS 在推广过程中对模块定义的规范化产出。
    - CMD是 SeaJS 在推广过程中对模块定义的规范化产出。
    - CMD推崇依赖就近，AMD推崇依赖前置。


- ES Module与CommonJS:
    - CommonJS模块是对象，是运行时加载，运行时才把模块挂载在exports之上（加载整个模块的所有），加载模块其实就是查找对象属性。
    - ES Module不是对象，是使用export显示指定输出，再通过import输入。此法为编译时加载，编译时遇到import就会生成一个只读引用。等到运行时就会根据此引用去被加载的模块取值。所以不会加载模块所有方法，仅取所需。
    - CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
    - CommonJS 模块是运行时加载，ES6 模块是编译时输出接口


- CommonJS与AMD/CMD:
    - AMD/CMD是CommonJS在浏览器端的解决方案。
    - CommonJS是同步加载（代码在本地，加载时间基本等于硬盘读取时间）。
    - AMD/CMD是异步加载（浏览器必须这么做，代码在服务端）


- UMD与AMD/CMD
    - UMD（Universal Module Definition）是AMD和CommonJS的糅合，跨平台的解决方案。
    - AMD模块以浏览器第一的原则发展，异步加载模块。
    - CommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。
    - UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。
    
